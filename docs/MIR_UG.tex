\documentclass[11pt,a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{framed}

\usepackage[parfill]{parskip}

\lstdefinestyle{MyInputStyle}{
	language=bash,
	basicstyle=\small\sffamily,
	commentstyle=\color{black},
	numberstyle=\tiny\color{black},
	keywordstyle=\color{black},
	extendedchars=true,
	numbers=none,
	numbersep=3pt,
	frame=none,
	columns=fullflexible,
	backgroundcolor=\color{gray!10},
	linewidth=\linewidth,
	breaklines=true,
	breakatwhitespace=false,
	showspaces=false,
	keepspaces=true,
	captionpos=b,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2,
	aboveskip=\bigskipamount,
	belowskip=\bigskipamount,
}

\lstdefinestyle{MyCStyle}{
	language=c,
	basicstyle=\small\sffamily,
	commentstyle=\color{black},
	numberstyle=\tiny\color{black},
	keywordstyle=\color{black},
	extendedchars=true,
	numbers=left,
	numbersep=3pt,
	frame=none,
	columns=fullflexible,
	backgroundcolor=\color{gray!10},
	linewidth=\linewidth,
	breaklines=true,
	breakatwhitespace=false,
	showspaces=false,
	keepspaces=true,
	captionpos=b,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2,
	aboveskip=\bigskipamount,
	belowskip=\bigskipamount,
}


\title{MIR User Guide}

\begin{document}
\maketitle

\section{Introduction}\label{introduction}

MIR is an experimental task-based runtime system library written using C99. Prominent features of MIR include:
\begin{itemize}
    \item Detailed per-task performance profiling and visualization.
    \item Flexible, high performance task scheduling and data distribution policies. Examples: Locality-aware scheduling and data distribution on NUMA systems, work-stealing scheduling for multicore systems.
    \item Support for a capable subset of OpenMP 3.0 tasks and parallel for-loops interface.
    \item Competitive performance for medium-grained task-based programs.
\end{itemize}

\section{Intended Audience}\label{intended-audience}

MIR is intended to be used by advanced task-based programmers. Knowledge of OpenMP compilation and role of runtime system in task-based programming is required to use and appreciate MIR.

\section{Installation}\label{installation}

MIR is built and tested on modern (2012+) Linux-based systems.

In order to build and use MIR for task-based program execution, you will minimally require:

\begin{itemize}
  \item A machine with x86 architecture.
  \item Linux kernel later than January 2012.
  \item GCC.
  \item Python (for executing scripts)
  \item GNU Binutils.
  \item Scons build system.
  \item R (for executing scripts)
  \item These R packages:
  \begin{itemize}
      \item data.table (for data structure transformations)
  \end{itemize}
\end{itemize}

Enabling core features such as per-task profiling and NUMA-specialized execution requires:

\begin{itemize}
\item Libraries libnuma and numactl (for data distribution and locality-aware scheduling on NUMA systems)
\item GCC with OpenMP support (for linking task-based OpenMP programs)
\item PAPI (for reading hardware performance counters during profiling)
\item Paraver (for visualizing thread execution traces)
\item Intel Pin sources (for profiling instructions executed by tasks)
\item These R packages:
  \begin{itemize}
  \item optparse (for parsing data)
  \item igraph (for task graph processing)
  \item RColorBrewer (for colors)
  \item ggplot2 and reshape2 (for plotting)
  \item gdata, plyr, dplyr (for data structure transformations)
  \end{itemize}
\item yEd (for task graph viewing, preferred)
\item Cytoscape (for task graph viewing)
\end{itemize}

\subsection{Source Structure}\label{source-structure}

The MIR source repository is easy to navigate. Files and directories have familiar, purpose-oriented names. The directory structure of MIR is as follows :

\begin{lstlisting}[style=MyInputStyle]
. : MIR_ROOT
|__docs : documentation
|__src : runtime system sources
    |__scheduling : scheduling policies
    |__arch : architecture specific code
|__scripts
    |__profiling : all things related to profiling
        |__task
            |__for_loop
        |__thread
|__tests : test suite.
|__examples : example programs.
\end{lstlisting}

\subsection{Licensing}\label{license}
MIR is released under the Apache 2.0 license.
As long as the MIR native library interface is used to compose task-based programs, the Apache 2.0 License is binding.

However, OpenMP in MIR support is enabled through a GPL (v3.0) implementation of the GNU libGOMP interface. Therefore a combination of Apache 2.0 License and GPL is applicable when OpenMP programs are linked with MIR. Understanding the implications of the combination is the responsibility of the reader.

\subsection{Build}\label{build}

Follow below steps to build the basic runtime system library.

\begin{itemize}
\item Set MIR\_ROOT environment variable.

\begin{lstlisting}[style=MyInputStyle]
$ export MIR_ROOT=<MIR source repository path>
\end{lstlisting}

\begin{framed}
\begin{quote}
Tip: Add the export statement to .bashrc to avoid repeated initialization.
\end{quote}
\end{framed}

\item Build.

\begin{lstlisting}[style=MyInputStyle]
$ cd $MIR_ROOT/src
$ scons
\end{lstlisting}
\end{itemize}

\subsubsection{Enabling data distribution and locality-aware scheduling on NUMA systems}\label{enabling-data-distribution-and-locality-aware-scheduling-on-numa-systems}

\begin{itemize}
\item Install libnuma and numactl.
\item Create an empty file called HAVE\_LIBNUMA.

\begin{lstlisting}[style=MyInputStyle]
$ touch $MIR_ROOT/src/HAVE_LIBNUMA
\end{lstlisting}

\item Clean and rebuild MIR.

\begin{lstlisting}[style=MyInputStyle]
$ cd $MIR_ROOT/src
$ scons -c && scons
\end{lstlisting}
\end{itemize}

\subsubsection{Enabling OpenMP support}\label{enable-omp-support}

\begin{itemize}
\item You should have received the GPL implementation of the libGOMP interface in a package separate from MIR sources. Point the environment variable MIR\_OMP\_INT\_ROOT to the location of the package.

\item Add the GPL implementation to the source directory and rebuild MIR.

\begin{lstlisting}[style=MyInputStyle]
$ cd $MIR_ROOT/src
$ ln -s $MIR_OMP_INT_ROOT/mir_omp_int.c mir_omp_int.c
\end{lstlisting}

\item Clean and rebuild MIR.

\begin{lstlisting}[style=MyInputStyle]
$ cd $MIR_ROOT/src
$ scons -c && scons
\end{lstlisting}
\end{itemize}

\subsection{Testing}\label{testing}

Run tests in MIR\_ROOT/tests.

\begin{lstlisting}[style=MyInputStyle]
$ cd $MIR_ROOT/tests
$ ./test-all.sh | tee test-all-result.txt
\end{lstlisting}

\subsection{Examples}\label{examples}

Run example programs in MIR\_ROOT/examples.

\begin{lstlisting}[style=MyInputStyle]
$ cd $MIR_ROOT/examples/OMP/fib
$ scons -u
$ ./fib-opt.out
\end{lstlisting}

\begin{framed}
\begin{quote}
Note: A dedicated suite of example task-based programs is available upon request.
\end{quote}
\end{framed}

\section{Programming}\label{programming}

\subsection{OpenMP Interface}\label{openmp-interface}

OpenMP support is restricted to the following interfaces:

\begin{itemize}
    \item Task creation: \texttt{task shared(list) private(list) firstprivate(list) default(shared|none)}
    \item Task synchronization: \texttt{taskwait}
    \item Parallel block: \texttt{parallel shared(list) private(list) firstprivate(list) num\_threads(integer\_expression)} default(shared|none)
    \item Single block: \texttt{single}
    \item For-loop: \texttt{for shared(list) private(list) firstprivate(list) lastprivate(list)} \texttt{reduction(reduction-identifier:list)} \\ \texttt{schedule(static|dynamic|runtime|guided[,chunk\_size])}. Can also be combined with \texttt{parallel} with applicable clauses.
    \item Serialization: \texttt{atomic}, \{\texttt{critical [,name]}\}, \texttt{barrier}
    \item Runtime functions: \texttt{omp\_get\_num\_threads, omp\_get\_thread\_num, \\omp\_get\_max\_threads, omp\_get\_wtime}
    \item Environment variables: \texttt{OMP\_NUM\_THREADS, OMP\_SCHEDULE}
\end{itemize}

\begin{framed}
\begin{quote}
Note: OpenMP tasks are supported by intercepting GCC translated calls to GNU libgomp. OpenMP 3.0 task interface support is therefore restricted to programs compiled using GCC.
\end{quote}
\end{framed}

\subsubsection{Tips for writing MIR-supported OpenMP programs}\label{tips-for-writing-mir-supported-openmp-programs}

\begin{itemize}
    \item Use \texttt{taskwait} explicitly to synchronize tasks. Do not expect implicit taskwaits within thread barriers.
        \item Avoid distributing work to threads manually.
        \item Study example and test programs.
        \item You can expect a compiler/runtime error when a non-supported interface is used.
\end{itemize}

\subsection{Native Interface}\label{native-interface}

The MIR library interface can also be directly used to compose task-based programs. Look at mir\_public\_int.h in MIR\_ROOT/src for interface details and example programs in MIR\_ROOT/examples/native for interface usage examples.

\subsection{Compiling and Linking}\label{compiling-and-linking}

Add \texttt{-lmir-opt} to \texttt{LDFLAGS}. Enable MIR to intercept outline function calls\\correctly by adding \texttt{{\footnotesize -fno-inline-functions -fno-inline-functions-called-once -fno-optimize-sibling-calls -fno-omit-frame-pointer -g}}  to \texttt{CFLAGS} and/or \\\texttt{CXXFLAGS}.

\subsection{Runtime Configuration}\label{runtime-configuration}

MIR has several runtime configurable options which can be set using the environment variable \texttt{MIR\_CONF}. Set the \texttt{-h} flag to see available configuration options.

\begin{lstlisting}[style=MyInputStyle]
$ MIR_CONF="-h" <invoke mir-linked program>
...
-h (--help) print this help message
-w <int> (--workers) number of workers
-s <str> (--schedule) task scheduling policy. Choose among central, central-stack, ws, ws-de and numa.
-m <str> (--memory-policy) memory allocation policy. Choose among coarse, fine and system.
--inlining-limit=<int> task inlining limit based on number of tasks per worker.
--stack-size=<int> worker stack size in MB
--queue-size=<int> task queue capacity
--numa-footprint=<int> for numa scheduling policy. Indicates data footprint size in bytes below which task is dealt to worker's private queue.
--worker-stats collect worker statistics
--task-stats collect task statistics
-r (--recorder) enable worker recorder
-p (--profiler) enable communication with Outline Function Profiler. Note: This option is supported only for single-worker execution!]
--single-parallel-block
\end{lstlisting}

\subsubsection{Binding workers to cores}\label{binding-workers-to-cores}

MIR creates and binds one worker thread per core by default. Hardware threads are excluded while binding. Binding is based on worker identifiers --- worker thread 0 is bound to core 0, worker thread 1 to core 1 and so on. The binding scheme can be changed to a specific mapping using the environment variable \texttt{MIR\_WORKER\_CORE\_MAP}. Ensure \texttt{MIR\_WORKER\_EXPLICIT\_BIND} is defined in \texttt{mir\_defines.h} to enable explicit binding support. An example is shown below.

\begin{lstlisting}[style=MyInputStyle]
$ cd $MIR_ROOT/src
$ grep "EXPLICIT_BIND" mir_defines.h
#define MIR_WORKER_EXPLICIT_BIND
$ cat /proc/cpuinfo | grep -c Core
4
$ export MIR_WORKER_CORE_MAP="0,2,3,1"
$ <invoke mir-linked program>
MIR_DBG: Starting initialization ...
MIR_DBG: Architecture set to firenze
MIR_DBG: Memory allocation policy set to system
MIR_DBG: Task scheduling policy set to central-stack
MIR_DBG: Reading worker to core map ...
MIR_DBG: Binding worker 0 to core 3
MIR_DBG: Binding worker 3 to core 0
MIR_DBG: Binding worker 2 to core 2
MIR_DBG: Worker 2 is initialized
MIR_DBG: Worker 3 is initialized
MIR_DBG: Binding worker 1 to core 1
...
\end{lstlisting}

\section{Profiling}\label{profiling}

MIR supports extensive and detailed thread-based and task-based profiling.

\subsection{Thread-based Profiling}\label{thread-based-profiling}

Thread states and events are the main performance indicators in thread-based profiling.

Enable the \texttt{--worker-stats} flag to get basic load-balance information in a CSV file called \texttt{mir-worker-stats}.

\begin{lstlisting}[style=MyInputStyle]
$ MIR_CONF="--worker-stats" <invoke mir-linked program>
$ cat mir-worker-stats
\end{lstlisting}

TODO: Explain file contents.

MIR contains a \texttt{recorder} which produces execution traces. Use the \texttt{-r} flag to enable the recorder and get detailed state and event traces in a set of \texttt{mir-recorder-trace-*.rec} files.  Each file represents a worker thread. The files can be inspected individually or combined and visualized using Paraver.

\begin{lstlisting}[style=MyInputStyle]
$ MIR_CONF="-r" <invoke mir-linked program>
$ $MIR_ROOT/scripts/profiling/thread/rec2paraver.py \
mir-recorder-trace-config.rec
$ wxparaver mir-recorder-trace.prv
\end{lstlisting}

Paraver configuration files for MIR traces are co-located with the script \texttt{rec2paraver.py}.

A set of \texttt{mir-recorder-state-time-*.rec} files are also created when \texttt{-r} is set. These files contain thread state duration information which can be accumulated for analysis without Paraver.

\begin{lstlisting}[style=MyInputStyle]
$ $MIR_ROOT/scripts/profiling/thread/get-states.sh \
mir-recorder-state-time
$ cat accumulated-state-file.info
\end{lstlisting}

TODO: Explain file contents.

\subsubsection{Enabling hardware performance counters}\label{enabling-hardware-performance-counters}

MIR can read hardware performance counters through PAPI during task execution events. Events currently supported are the beginning and end of task execution.
Hardware performance counters are not read during during a task switch event.

\begin{itemize}
\item Install PAPI.
\item Set the \texttt{PAPI\_ROOT} environment variable

\begin{lstlisting}[style=MyInputStyle]
$ export PAPI_ROOT=<PAPI install path>
\end{lstlisting}

\item Create a file called \texttt{HAVE\_PAPI} in MIR\_ROOT/src.

\begin{lstlisting}[style=MyInputStyle]
$ touch $MIR_ROOT/src/HAVE_PAPI
\end{lstlisting}

\item Enable additional PAPI hardware performance counters by editing \texttt{MIR\_ROOT/src/mir\_recorder.c}.

\begin{lstlisting}[style=MyInputStyle]
$ grep -i "{PAPI_" $MIR_ROOT/src/mir_recorder.c
{"PAPI_TOT_INS", 0x0},
{"PAPI_TOT_CYC", 0x0},
/*{"PAPI_L2_DCM", 0x0},*/
/*{"PAPI_RES_STL", 0x0},*/
/*{"PAPI_L1_DCA", 0x0},*/
/*{"PAPI_L1_DCH", 0x0},*/
\end{lstlisting}

\item Rebuild MIR.

\begin{lstlisting}[style=MyInputStyle]
$ scons -c && scons
\end{lstlisting}
\end{itemize}

Performance counter values will appear in the \texttt{mir-recorder-trace-*.rec} files produced by the recorder during thread-based profiling. The counter readings can either be viewed on Paraver or accumulated for analysis outside Paraver.

\begin{lstlisting}[style=MyInputStyle]
$ $MIR_ROOT/scripts/profiling/thread/get-events.sh mir-recorder-trace.prv
$ cat event-summary-*.txt
\end{lstlisting}

TODO: Explain file contents.

\subsection{Task-based Profiling}\label{task-based-profiling}

Task are first-class citizens in task-based profiling.

Enable the \texttt{--task-stats} flag to collect task statistics in a CSV file called \texttt{mir-task-stats}. Inspect the file manually or plot and visualize the fork-join task graph.

\begin{lstlisting}[style=MyInputStyle]
$ MIR_CONF="--task-stats" <invoke mir-linked program>
$ Rscript ${MIR_ROOT}/scripts/profiling/task/plot-task-graph.R -d mir-task-stats
\end{lstlisting}

TODO: Explain file contents.

The \texttt{mir-task-stats} file can be further processed for additional information such as number of tasks and task lineage (run-independent unique identifier for tasks). Processed information can also be used to visualize the fork-join task graph.

\begin{lstlisting}[style=MyInputStyle]
$ Rscript ${MIR_ROOT}/scripts/profiling/task/process-task-stats.R -d mir-task-stats --lineage
$ cat task-stats.info
$ head task-stats.processed
$ Rscript ${MIR_ROOT}/scripts/profiling/task/plot-task-graph.R -d task-stats.processed
\end{lstlisting}

TODO: Explain file contents.

Hardware performance counter readings obtained during thread-based profiling can be summarized on a per-task basis. Note that performance counter readings will include the effects of all actions that occurred during task execution such as runtime system activity, system calls, interrupts etc.

\begin{lstlisting}[style=MyInputStyle]
$ $MIR_ROOT/scripts/profiling/thread/get-events-per-task.sh mir-recorder-trace-*.rec
$ cat accumulated-events.summary
$ cat accumulated-events.table
\end{lstlisting}

TODO: Explain file contents.

\subsubsection{Instruction-level task profiling}\label{instruction-level-task-profiling}

MIR provides a Pin-based instruction profiler for tasks called the \textit{Outline Function Profiler}.
The profiler traces instructions executed within outline functions of tasks in programs compiled with GCC. Instructions of dynamically linked functions and system calls called within the outline function are not traced. Read paper \textit{Characterizing task-based OpenMP programs} (DOI: 10.1371/journal.pone.0123545) for more details.

Follow below steps to build and use the profiler.

\begin{itemize}
\item Get Intel Pin sources and set environment variables.

\begin{lstlisting}[style=MyInputStyle]
$ export PIN_ROOT=<Pin source path>
$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$PIN_ROOT:$PIN_ROOT/intel64/runtime
\end{lstlisting}

\item Edit \texttt{PIN\_ROOT/source/tools/Config/makefile.unix.config} and add \texttt{-fopenmp} to variables \texttt{TOOL\_LDFLAGS\_NOOPT}  and \texttt{TOOL\_CXXFLAGS\_NOOPT}

\item Build the profiler.

\begin{lstlisting}[style=MyInputStyle]
$ cd $MIR_ROOT/scripts/profiling/task
$ make PIN_ROOT=$PIN_ROOT
\end{lstlisting}

\item View profiler options using \texttt{-h}.

\begin{lstlisting}[style=MyInputStyle]
$ $PIN_ROOT/intel64/bin/pinbin -t $MIR_ROOT/scripts/profiling/task/obj-intel64/mir_of_profiler.so -h -- /usr/bin/echo
...
-of specify outline functions (csv)
-cf specify functions called from outline functions (csv)
-df specify dynamically library functions called from outline functions (csv)
-pr output file prefix [default mir-ofp]
...
\end{lstlisting}

Runtime system function calls made within tasks are not profiled and attributed to tasks by default.
If profiling and attribution of runtime system function calls to tasks is required, provide \texttt{-ni} flag argument.

\item The profiler requires handshaking with the runtime system. To enable handshaking, enable the \texttt{-p} flag in MIR\_CONF.

\item The profiler requires single-threaded execution of the profiled program. Provide \texttt{-w 1} in MIR\_CONF while profiling.

\item Information from the profiler becomes more meaningful when correlated with task statistics information. Provide \texttt{--task-stats} in MIR\_CONF while profiling.

\item Use script \texttt{of\_finder.py} to find outline functions and functions called within outline functions.

\item Create a handy shell function for invoking the profiler and to enable task statistics collection.

\begin{lstlisting}[style=MyInputStyle]
$ type mir-inst-prof 
mir-inst-prof is a function
mir-inst-prof () 
{ 
    MIR_CONF='-w 1 -p --task-stats --single-parallel-block' ${PIN_ROOT}/intel64/bin/pinbin -t ${MIR_ROOT}/scripts/profiling/task/obj-intel64/mir_of_profiler.so "$@"
}
\end{lstlisting}

\item The profiler takes approximately 36X  the time to execute the program on a single core and produces three CSV files -- \texttt{mir-ofp-instructions, mir-ofp-events} and \texttt{mir-task-stats}.

TODO: Explain file contents.

\end{itemize}

\subsubsection{Visualization}

MIR has a nice graph plotter which can transform task-based profiling data into task graphs. The generated graph can be visualized on tools such as yEd and Cytoscape.  To plot the fork-join task graph using task statistics from the runtime system:

\begin{lstlisting}[style=MyInputStyle]
$ Rscript ${MIR_ROOT}/scripts/profiling/task/plot-task-graph.R -d task-stats.processed -p color
\end{lstlisting}

\begin{framed}
\begin{quote}
Tip: The graph plotter will plot in gray scale if \texttt{gray} is supplied instead of \texttt{color} as the palette (\texttt{-p}) argument. Critical path enumeration usually takes time. To speed up, skip critical path enumeration and calculate only its length using option \texttt{--cplengthonly}.
\end{quote}
\end{framed}

The graph plotter can annotate task graph elements with performance information. Merge the instruction-level information produced by the instruction profiler with the task statistics produced by the runtime system, for the same run, into a single CSV file. Plot task graph using combined performance information.

\begin{lstlisting}[style=MyInputStyle]
$ Rscript ${MIR_ROOT}/scripts/profiling/task/process-task-stats.R -d mir-task-stats
$ Rscript ${MIR_ROOT}/scripts/profiling/task/merge-task-performance.R -l task-stats.processed -r mir-ofp-instructions -k "task" -o mir-task-perf
$ Rscript ${MIR_ROOT}/scripts/profiling/task/plot-task-graph.R -d mir-task-perf -p color
\end{lstlisting}

TODO: Instructions to use the full task graph profiler.

\subsection{Profiling Case Study}

TODO.

\end{document}
