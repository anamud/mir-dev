\documentclass[11pt,a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{framed}

\usepackage[parfill]{parskip}

\lstdefinestyle{MyInputStyle}{
	language=bash,
	basicstyle=\small\sffamily,
	commentstyle=\color{black},
	numberstyle=\tiny\color{black},
	keywordstyle=\color{black},
	extendedchars=true,
	numbers=none,
	numbersep=3pt,
	frame=none,
	columns=fullflexible,
	backgroundcolor=\color{gray!10},
	linewidth=\linewidth,
	breaklines=true,
	breakatwhitespace=false,
	showspaces=false,
	keepspaces=true,
	captionpos=b,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2,
	aboveskip=\bigskipamount,
	belowskip=\bigskipamount,
}

\lstdefinestyle{MyCStyle}{
	language=c,
	basicstyle=\small\sffamily,
	commentstyle=\color{black},
	numberstyle=\tiny\color{black},
	keywordstyle=\color{black},
	extendedchars=true,
	numbers=left,
	numbersep=3pt,
	frame=none,
	columns=fullflexible,
	backgroundcolor=\color{gray!10},
	linewidth=\linewidth,
	breaklines=true,
	breakatwhitespace=false,
	showspaces=false,
	keepspaces=true,
	captionpos=b,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2,
	aboveskip=\bigskipamount,
	belowskip=\bigskipamount,
}


\title{MIR User Guide}

\begin{document}
\maketitle

\section{Introduction}\label{introduction}

MIR is an experimental task-based runtime system library written using C99. Prominent features of MIR include:
\begin{itemize}
    \item Detailed per-task performance profiling and visualization.
    \item Flexible, high performance task scheduling and data distribution policies. Example: Locality-aware scheduling and data distribution on NUMA systems, work-stealing scheduling for multicore systems.
    \item Supports for a capable subset of the OpenMP 3.0 tasks interface.
    \item Competitive performance for medium-grained task-based programs.
\end{itemize}

\section{Intended Audience}\label{intended-audience}

MIR is intended to be used by advanced task-based programmers. Knowledge of OpenMP compilation and role of runtime system in task-based programming is required to use and appreciate MIR.

\section{Installation}\label{installation}

MIR is built and tested on modern (2012+) Linux-based systems. 

In order to build and use MIR for task-based program execution, you will minimally require:

\begin{itemize}
  \item A machine with x86 architecture.
  \item Linux kernel later than January 2012.
  \item GCC.
  \item Python (for executing scripts)
  \item GNU Binutils.
  \item Scons build system.
  \item R (for executing scripts)
  \item These R packages:
  \begin{itemize}
      \item data.table (for data structure transformations)
  \end{itemize}
\end{itemize}

Enabling core features such as per-task profiling and NUMA-specialized execution requires:

\begin{itemize}
\item Libraries libnuma and numactl (for data distribution and locality-aware scheduling on NUMA systems)
\item GCC with OpenMP support (for linking task-based OpenMP programs)
\item PAPI (for reading hardware performance counters during profiling)
\item Paraver (for visualizing thread execution traces)
\item Intel Pin sources (for profiling instructions executed by tasks)
\item These R packages:
  \begin{itemize}
  \item optparse (for parsing data)
  \item igraph (for task graph processing)
  \item RColorBrewer (for colors)
  \item gdata, plyr, dplyr (for data structure transformations)
  \end{itemize}
\item yEd (for task graph viewing, preferred)
\item Graphviz (for task graph viewing)
\item Cytoscape (for task graph viewing)
\end{itemize}

\subsection{Source Structure}\label{source-structure}

The MIR source repository is easy to navigate. Files and directories have familiar, purpose-oriented names. The directory structure of MIR is as follows :

\begin{lstlisting}[style=MyInputStyle]
. : MIR_ROOT
|__docs : documentation
|__src : runtime system sources
    |__scheduling : scheduling policies
    |__arch : architecture specific code
|__scripts
    |__helpers : helpful scripts, one-time hacks
    |__profiling : all things related to profiling
        |__task
        |__thread
|__programs : test programs, benchmarks
    |__common : build scripts
    |__native : native interface programs
        |__fib : Fibonacci program
            |__helpers : testing scripts
        |__bots : BOTS port
    |__omp : OpenMP interface programs
        |__fib
        |__bots
\end{lstlisting}

\subsection{Build}\label{build}

Follow below steps to build the basic runtime system library.

\begin{itemize}
\item Set MIR\_ROOT environment variable.

\begin{lstlisting}[style=MyInputStyle]
$ export MIR_ROOT=<MIR source repository path>
\end{lstlisting}

\begin{framed}
\begin{quote}
Tip: Add the export statement to .bashrc to avoid repeated initialization.
\end{quote}
\end{framed}

\item Build.

\begin{lstlisting}[style=MyInputStyle]
$ cd $MIR_ROOT/src
$ scons
\end{lstlisting}
\end{itemize}

\begin{framed}
\begin{quote}
Expert Tip: Ensure MIR\_ROOT/src/SConstruct matches your build intention.
\end{quote}
\end{framed}

\subsubsection{Enabling data distribution and locality-aware scheduling on NUMA systems}\label{enabling-data-distribution-and-locality-aware-scheduling-on-numa-systems}

\begin{itemize}
\item Install libnuma and numactl.
\item Create an empty file called HAVE\_LIBNUMA.

\begin{lstlisting}[style=MyInputStyle]
$ touch $MIR_ROOT/src/HAVE_LIBNUMA
\end{lstlisting}

\item Clean and rebuild MIR.

\begin{lstlisting}[style=MyInputStyle]
$ cd $MIR_ROOT/src
$ scons -c && scons
\end{lstlisting}
\end{itemize}

\subsection{Testing}\label{testing}

Try different runtime system configurations and program inputs on Fibonacci in MIR\_ROOT/programs/native/fib. All programs under \\ MIR\_ROOT/programs can be used for testing.

\begin{lstlisting}[style=MyInputStyle]
$ cd $MIR_ROOT/programs/native/fib
$ scons -c
$ scons
$ ./fib-verbose
$ ./fib-debug
$ ./fib-opt
\end{lstlisting}

\begin{framed}
\begin{quote}
Note: A dedicated test suite will be added soon, so watch out for that!
\end{quote}
\end{framed}

\section{Programming}\label{programming}

\subsection{OpenMP 3.0 Tasks Interface}\label{openmp-3.0-tasks-interface}

A restricted subset of OpenMP 3.0 tasks --- the \texttt{task} and \texttt{taskwait} constructs --- is supported. Although minimal, the subset is sufficient for writing most task-based programs.

\begin{framed}
\begin{quote}
Note: OpenMP tasks are supported by intercepting GCC translated calls to GNU libgomp. OpenMP 3.0 task interface support is therefore restricted to programs compiled using GCC.
\end{quote}
\end{framed}

\subsubsection{Tips for writing MIR-supported OpenMP programs}\label{tips-for-writing-mir-supported-openmp-programs}

\begin{itemize}
    \item Think solely in terms of OpenMP 3.0 tasks.
    \begin{itemize}
        \item Use the \texttt{task} construct to parallelize work.
        \item Use clauses \texttt{shared}, \texttt{firstprivate} and \texttt{private} to indicate the data environment.
        \item Use \texttt{taskwait} to synchronize tasks.
        \item Use taskwait explicitly. Do not expect implicit taskwaits within thread barriers.
    \end{itemize}
    \item Fully avoid thinking in terms of threads.
    \begin{itemize}
        \item Use the \texttt{parallel} construct only to create a team of threads.
        \item Do not specify the number of threads using either the \texttt{num\_threads} clause or the \texttt(OMP\_NUM\_THREADS) environment variable.
        \item Do not use the \texttt{parallel} construct to share work.
        \item Do not use barriers to synchronize threads. Do not expect implicit barriers at the end parallel blocks.
    \end{itemize}
    \item Use GCC atomic builtins for flushing and atomic operations.
    \item Study example programs in MIR\_ROOT/programs/omp.
\end{itemize}

A simple set of steps for producing MIR-supported OpenMP programs is given below:

\begin{enumerate}
\item When parallel execution is required, create a \texttt{parallel}  block followed immediately by a \texttt{single} block.
\item Use the \texttt{task} construct within the \texttt{single} block to parallelize work.
\item Synchronize tasks using the \texttt{taskwait} construct explicitly. Do not rely on implicit barriers and taskwaits.
\item It is strongly recommended to parallelize work inside a master task context. This simplifies interpreting MIR profiling results.
\item Compile and link with the native GCC OpenMP implementation. Ensure the program runs correctly.
\item Ensure that \texttt{parallel} block do not share work and that all tasks are synchronized explicitly.
\item Compile and link with the appropriate MIR library (opt/debug). The program is now ready.
\end{enumerate}

An example program built using above steps follows.

\begin{lstlisting}[style=MyCStyle]
int main(int argc, char *argv[])
{
#pragma omp parallel
{
#pragma omp single
{
// Create master task
#pragma omp task
{
    // Now parallelize the work.
    // For example, lets say the work is to
    // ... create a 1000 parallel instances of the fuction foo.
    for(int i=0; i<1000; i++)
    {
        #pragma omp task firstprivate(i)
            foo(i);
    }

    // Wait for tasks to finish
    #pragma omp taskwait
}
// Wait for master task to finish
#pragma omp taskwait
} // omp single end
} // omp parallel end

    return 0;
}
\end{lstlisting}

\subsection{Native Interface}\label{native-interface}

The MIR library interface can also be directly used to compose task-based programs. Look at mir\_public\_int.h in MIR\_ROOT/src for interface details and programs in MIR\_ROOT/programs/native for interface usage examples. A simple program using the native interface is shown\\below.

\begin{lstlisting}[style=MyCStyle]
#include "mir_public_int.h"
void foo(int id)
{
    printf(stderr, "Hello from task %d\n", id);
}

// Outline function for foo.
struct foo_of_arg_t
{
    int id;
};
void foo_of(void* arg)
{
    struct foo_of_arg_t* farg = (struct foo_of_arg_t*)(arg);
    foo(farg->id);
}

// The master task
// Having a master task helps to interpret profiling results
void master_task()
{
    // Create a 1000 instance of foo.
    for(int i=0; i<1000; i++)
    {
        struct foo_of_arg_t arg;
        arg.id = i;
        mir_task_create((mir_tfunc_t) foo_of,
                        &arg,
                        sizeof(struct foo_of_arg_t),
                        0, NULL, NULL);
    }

    // Wait for tasks to finish
    mir_task_wait();
}

// Outline function for the master task
void master_task_of(void* arg)
{
    master_task();
}

int main(int argc, char *argv[])
{
    // Initialize the runtime system
    mir_create();

    // Create master task
    mir_task_create((mir_tfunc_t) master_task_of,
                    NULL,
                    0,
                    0, NULL, NULL);

    // Wait for master task to finish
    mir_task_wait();

    // Release runtime system resources
    mir_destroy();

    return 0;
}
\end{lstlisting}

\subsection{Compiling and Linking}\label{compiling-and-linking}

Add \texttt{-lmir-opt} to \texttt{LDFLAGS}. Enable MIR to intercept function calls\\correctly by adding \texttt{{\footnotesize -fno-inline-functions -fno-inline-functions-called-once -fno-optimize-sibling-calls -fno-omit-frame-pointer -g}}  to \texttt{CFLAGS} and/or \texttt{CXXFLAGS}.

\subsection{Runtime Configuration}\label{runtime-configuration}

MIR has several runtime configurable options which can be set using the environment variable \texttt{MIR\_CONF}. Set the \texttt{-h} flag to see available configuration options.

\begin{lstlisting}[style=MyInputStyle]
$ cd $MIR_ROOT/test/fib
$ scons
$ MIR_CONF="-h" ./fib-opt 3
MIR_INFO: Valid options in MIR_CONF environment variable ...
-h (--help) print this help message
-w <int> (--workers) number of workers
-s <str> (--schedule) task scheduling policy. Choose among central, central-stack, ws, ws-de and numa.
-m <str> (--memory-policy) memory allocation policy. Choose among coarse, fine and system.
--inlining-limit=<int> task inlining limit based on number of tasks per worker.
--stack-size=<int> worker stack size in MB
--queue-size=<int> task queue capacity
--numa-footprint=<int> for numa scheduling policy. Indicates data footprint size in bytes below which task is dealt to worker's private queue.
--worker-stats collect worker statistics
--task-stats collect task statistics
-r (--recorder) enable worker recorder
-p (--profiler) enable communication with Outline Function Profiler. Note: This option is supported only for single-worker execution!]
\end{lstlisting}

\subsubsection{Binding workers to cores}\label{binding-workers-to-cores}

MIR creates and binds one worker thread per core by default. Hardware threads are excluded while binding. Binding is based on worker identifiers --- worker thread 0 is bound to core 0, worker thread 1 to core 1 and so on. The binding scheme can be changed to a specific mapping using the environment variable \texttt{MIR\_WORKER\_CORE\_MAP}. Ensure \texttt{MIR\_WORKER\_EXPLICIT\_BIND} is defined in \texttt{mir\_defines.h} to enable explicit binding support. An example is shown below.

\begin{lstlisting}[style=MyInputStyle]
$ cd $MIR_ROOT/src
$ grep "EXPLICIT_BIND" mir_defines.h
#define MIR_WORKER_EXPLICIT_BIND
$ cat /proc/cpuinfo | grep -c Core
4
$ export MIR_WORKER_CORE_MAP="0,2,3,1"
$ cd $MIR_ROOT/programs/native/fib
$ scons
$ ./fib-debug 10 3
MIR_DBG: Starting initialization ...
MIR_DBG: Architecture set to firenze
MIR_DBG: Memory allocation policy set to system
MIR_DBG: Task scheduling policy set to central-stack
MIR_DBG: Reading worker to core map ...
MIR_DBG: Binding worker 0 to core 3
MIR_DBG: Binding worker 3 to core 0
MIR_DBG: Binding worker 2 to core 2
MIR_DBG: Worker 2 is initialized
MIR_DBG: Worker 3 is initialized
MIR_DBG: Binding worker 1 to core 1
...
\end{lstlisting}

\section{Profiling}\label{profiling}

MIR supports extensive and detailed thread-based and task-based profiling.

\subsection{Thread-based Profiling}\label{thread-based-profiling}

Thread states and events are the main performance indicators in thread-based profiling.

Enable the \texttt{--worker-stats} flag to get basic load-balance information in a CSV file called \texttt{mir-worker-stats}.

\begin{lstlisting}[style=MyInputStyle]
$ MIR_CONF="--worker-stats" ./fib-opt
$ cat mir-worker-stats
\end{lstlisting}

TODO: Explain file contents.

MIR contains a \texttt{recorder} which produces execution traces. Use the \texttt{-r} flag to enable the recorder and get detailed state and event traces in a set of \texttt{mir-recorder-trace-*.rec} files.  Each file represents a worker thread. The files can be inspected individually or combined and visualized using Paraver.

\begin{lstlisting}[style=MyInputStyle]
$ MIR_CONF="-r" ./fib-opt
$ $MIR_ROOT/scripts/profiling/thread/rec2paraver.py \
mir-recorder-trace-config.rec
$ wxparaver mir-recorder-trace.prv
\end{lstlisting}

A set of \texttt{mir-recorder-state-time-*.rec} files are also created when \texttt{-r} is set. These files contain thread state duration information which can be accumulated for analysis without Paraver.

\begin{lstlisting}[style=MyInputStyle]
$ $MIR_ROOT/scripts/profiling/thread/get-states.sh \
mir-recorder-state-time
$ cat accumulated-state-file.info
\end{lstlisting}

TODO: Explain file contents.

\subsubsection{Enabling hardware performance counters}\label{enabling-hardware-performance-counters}

MIR can read hardware performance counters through PAPI during task execution events. Events currently supported are the beginning and end of task execution.
Hardware performance counters are not read during during a task switch event.

\begin{itemize}
\item Install PAPI.
\item Set the \texttt{PAPI\_ROOT} environment variable

\begin{lstlisting}[style=MyInputStyle]
$ export PAPI_ROOT=<PAPI install path>
\end{lstlisting}

\item Create a file called \texttt{HAVE\_PAPI} in MIR\_ROOT/src.

\begin{lstlisting}[style=MyInputStyle]
$ touch $MIR_ROOT/src/HAVE_PAPI
\end{lstlisting}

\item Enable additional PAPI hardware performance counters by editing \texttt{MIR\_ROOT/src/mir\_recorder.c}.

\begin{lstlisting}[style=MyInputStyle]
$ grep -i "{PAPI_" $MIR_ROOT/src/mir_recorder.c
{"PAPI_TOT_INS", 0x0},
{"PAPI_TOT_CYC", 0x0},
/*{"PAPI_L2_DCM", 0x0},*/
/*{"PAPI_RES_STL", 0x0},*/
/*{"PAPI_L1_DCA", 0x0},*/
/*{"PAPI_L1_DCH", 0x0},*/
\end{lstlisting}

\item Rebuild MIR.

\begin{lstlisting}[style=MyInputStyle]
$ scons -c && scons
\end{lstlisting}
\end{itemize}

Performance counter values will appear in the \texttt{mir-recorder-trace-*.rec} files produced by the recorder during thread-based profiling. The counter readings can either be viewed on Paraver or accumulated for analysis outside Paraver.

\begin{lstlisting}[style=MyInputStyle]
$ $MIR_ROOT/scripts/profiling/thread/get-events.sh mir-recorder-trace.prv
$ cat event-summary-*.txt
\end{lstlisting}

TODO: Explain file contents.

\subsection{Task-based Profiling}\label{task-based-profiling}

Task are first-class citizens in task-based profiling.

Enable the \texttt{--task-stats} flag to collect task statistics in a CSV file called \texttt{mir-task-stats}. Inspect the file manually or plot and visualize the fork-join task graph.

\begin{lstlisting}[style=MyInputStyle]
$ MIR_CONF="--task-stats" ./fib-opt
$ Rscript ${MIR_ROOT}/scripts/profiling/task/plot-task-graph.R -d mir-task-stats
\end{lstlisting}

TODO: Explain file contents.

The \texttt{mir-task-stats} file can be further processed for additional information such as number of tasks and task lineage (run-independent unique identifier for tasks). Processed information can also be used to visualize the fork-join task graph.

\begin{lstlisting}[style=MyInputStyle]
$ Rscript ${MIR_ROOT}/scripts/profiling/task/process-task-stats.R -d mir-task-stats --lineage
$ cat mir-task-stats.info
$ head mir-task-stats.lineage
$ head mir-task-stats.processed
$ Rscript ${MIR_ROOT}/scripts/profiling/task/plot-task-graph.R -d mir-task-stats.processed
\end{lstlisting}

TODO: Explain file contents.

Hardware performance counter readings obtained during thread-based profiling can be summarized on a per-task basis. Note that performance counter readings will include the effects of all actions that occured during task execution such as runtime system activity, system calls, interrupts etc.

\begin{lstlisting}[style=MyInputStyle]
$ $MIR_ROOT/scripts/profiling/thread/get-events-per-task.sh mir-recorder-trace-*.rec
$ cat accumulated-events.summary
$ cat accumulated-events.table
\end{lstlisting}

TODO: Explain file contents.

\subsubsection{Instruction-level task profiling}\label{instruction-level-task-profiling}

MIR provides a Pin-based instruction profiler for tasks called the \textit{Outline Function Profiler}.
The profiler traces instructions executed within outline functions of tasks in programs compiled with GCC. Instructions of dynamically linked functions and system calls called within the outline function are not traced. Read paper \textit{Characterizing task-based OpenMP programs} (DOI: 10.1371/journal.pone.0123545) for more details.

Follow below steps to build and use the profiler.

\begin{itemize}
\item Get Intel Pin sources and set environment variables.

\begin{lstlisting}[style=MyInputStyle]
$ export PIN_ROOT=<Pin source path>
$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$PIN_ROOT:$PIN_ROOT/intel64/runtime
\end{lstlisting}

\item Edit \texttt{PIN\_ROOT/source/tools/Config/makefile.unix.config} and add \texttt{-fopenmp} to variables \texttt{TOOL\_LDFLAGS\_NOOPT}  and \texttt{TOOL\_CXXFLAGS\_NOOPT}

\item Build the profiler.

\begin{lstlisting}[style=MyInputStyle]
$ cd $MIR_ROOT/scripts/profiling/task
$ make PIN_ROOT=$PIN_ROOT
\end{lstlisting}

\item View profiler options using \texttt{-h}.

\begin{lstlisting}[style=MyInputStyle]
$ $PIN_ROOT/intel64/bin/pinbin -t $MIR_ROOT/scripts/profiling/task/obj-intel64/mir_of_profiler.so -h -- /usr/bin/echo
...
-of specify outline functions (csv)
-cf specify functions called (csv) from outline functions
-pr output file prefix [default mir-ofp]
...
\end{lstlisting}

The profiler requires outline function names under the argument \texttt{-of}. The argument \texttt{-cf} accepts names of functions which are called within tasks. The argument \texttt{--} separates profiled program invocation from profiler arguments.

\item The profiler requires handshaking with the runtime system. To enable handshaking, enable the \texttt{-p} flag in MIR\_CONF.

\item The profiler requires single-threaded execution of the profiled program. Provide \texttt{-w 1} in MIR\_CONF while profiling.

\item Information from the profiler becomes more meaningful when correlated with task statistics information. Provide \texttt{--task-stats} in MIR\_CONF while profiling.

\item Create a handy shell function for invoking the profiler and to enable task statistics collection.

\begin{lstlisting}[style=MyInputStyle]
function mir-inst-prof()
{
    MIR_CONF='-w 1 -p --task-stats' ${PIN_ROOT}/intel64/bin/pinbin -t ${MIR_ROOT}/scripts/profiling/task/obj-intel64/mir_of_profiler.so "$@"
}
\end{lstlisting}
\end{itemize}

The profiler produces following outputs:
\begin{itemize}
    \item Per-task instructions in a CSV file called \texttt{mir-ofp-instructions}. Example contents of the file are shown below.  TODO: Add file contents.  Each line shows instruction and code properties of a distinct task executed by the program. Properties are described below.
        \begin{itemize}
            \item task: Identifier of the task.
            \item ins\_count: Total number of instructions executed by the task excluding instructions of system calls, dynamically linked functions and runtime system functions.
            \item stack\_read: Number of read accesses to the stack while executing instructions.
            \item stack\_write: Number of write accesses to the stack while executing instructions.
            \item ccr: Computation to Communication Ratio. Indicates number of instructions executed per read or write access to memory.
            \item clr: Computation to Load Ratio. Indicates number of instructions executed per read access to memory.
            \item mem\_read: Number of read accesses to memory (excluding stack) while executing instructions.
            \item mem\_write: Number of write accesses to memory (excluding stack) while executing instructions.
            \item outl\_func: Name of the outline function of the task.
        \end{itemize}
    \item Per-task events in a file called \texttt{mir-ofp-events}. Example contents of the file are shown below.
\begin{lstlisting}[style=MyInputStyle]
task,ins_count,[create],[wait]
14,446,[],[]
15,278,[],[]
10,60,[32,43,],[47,]
\end{lstlisting}
        Each line in the file shows events for a distinct task executed by the program. Event occurance is indicated in terms of instruction count. Events currently supported are:
        \begin{itemize}
            \item \texttt{create}: Indicates when child tasks were created. Example: [32,43] indicates the task 10 created its first child at instruction 32 and second child at 43. Tasks 14 and 15 did not create children tasks.
            \item \texttt{wait}: Indicates when child tasks were synchronized. Example: [47,] indicates the task 10 synchronized with all children created prior at instruction 47.
        \end{itemize}
    \item Program memory map in a file called \texttt{mir-ofp-mem-map}. This is a copy of the memory map file of the program from the /proc filesystem.
\end{itemize}

\subsubsection{Visualization}

MIR has a nice graph plotter which can transform task-based profiling data into task graphs. The generated graph can be visualized on tools such as Graphviz, yEd and Cytoscape.  To plot the fork-join task graph using task statistics from the runtime system:

\begin{lstlisting}[style=MyInputStyle]
$ Rscript ${MIR_ROOT}/scripts/profiling/task/plot-task-graph.R -d mir-task-stats.processed -p color
\end{lstlisting}

\begin{framed}
\begin{quote}
Tip: The graph plotter will plot in gray scale if \texttt{gray} is supplied instead of \texttt{color} as the palette (\texttt{-p}) argument. Critical path enumeration usually takes time. To speed up, skip critical path enumeration and calculate only its length using option \texttt{--cplengthonly}. Huge graphs with 50000+ tasks take a long time to plot. To save time, plot the task graph as a tree using option \texttt{--tree}.
\end{quote}
\end{framed}

The graph plotter can annotate task graph elements with performance information. Merge the instruction-level information produced by the instruction profiler with the task statistics produced by the runtime system, for the same run, into a single CSV file. Plot task graph using combined performance information.

\begin{lstlisting}[style=MyInputStyle]
$ Rscript ${MIR_ROOT}/scripts/profiling/task/process-task-stats.R -d mir-task-stats
$ Rscript ${MIR_ROOT}/scripts/profiling/task/merge-task-performance.R -l mir-task-stats.processed -r mir-ofp-instructions -k "task" -o mir-task-perf
$ Rscript ${MIR_ROOT}/scripts/profiling/task/plot-task-graph.R -d mir-task-perf -p color
\end{lstlisting}

TODO: Instructions to use the full task graph profiler.

\subsection{Profiling Case Study: Fibonacci}

The Fibonacci program is found in MIR\_ROOT/programs/native/fib. The program takes two arguments -- the number n and the depth cutoff for recursive task creation. Let us see how to profile the program for task-based performance information.

Compile the program for profiling -- remove aggressive optimizations and disable inlining so that outline functions representing tasks are visible to the Pin-based instruction profiler. Running scons in the program directory builds the profiler-friendly executable called \texttt{fib-prof}.

\begin{lstlisting}[style=MyInputStyle]
$ cd $MIR_ROOT/programs/native/fib
$ scons
scons: Reading SConscript files ...
scons: done reading SConscript files.
scons: Building targets ...
scons: building associated VariantDir targets: debug-build opt-build prof-build verbose-build
...
gcc -o prof-build/fib.o -c -std=c99 -Wall -Werror -Wno-unused-function -Wno-unused-variable -Wno-unused-but-set-variable -Wno-maybe-uninitialized -fopenmp -DLINUX -I/home/ananya/mir-dev/src -I/home/ananya/mir-dev/programs/common -O2 -DNDEBUG -fno-inline-functions -fno-inline-functions-called-once -fno-optimize-sibling-calls -fno-omit-frame-pointer -g fib.c
...
gcc -o fib-prof prof-build/fib.o -L/home/ananya/mir-dev/src -lpthread -lm -lmir-opt
\end{lstlisting}

\begin{framed}
\begin{quote}
Tip: Look at the \texttt{SConstruct} file in MIR\_ROOT/test/fib and build output to understand how the profiling-friendly build is done.
\end{quote}
\end{framed}

Identify outline functions and functions called within tasks of the \texttt{fib-prof} program using the script \texttt{of\_finder.py}. The script searches for known outline function name patterns within the object files of \texttt{fib-prof}. The script lists outline functions as \texttt{CHECKME\_OUTLINE\_FUNCTIONS} and all function symbols within the object files as \texttt{CHECKME\_CALLED\_FUNCTIONS}.

\begin{lstlisting}[style=MyInputStyle]
$ cd $MIR_ROOT/programs/native/fib
$ $MIR_ROOT/scripts/profiling/task/of_finder.py -v prof-build/*.o
Using "._omp_fn.|ol_" as outline function name pattern
Processing file: prof-build/fib.o
CHECKME_OUTLINE_FUNCTIONS=ol_fib_0,ol_fib_1,ol_fib_2
CHECKME_CALLED_FUNCTIONS=fib_seq,fib,get_usecs,main
\end{lstlisting}

\begin{framed}
\begin{quote}
Expert Tip: Ensure that functions listed by CHECKME\_OUTLINE\_FUNCTIONS are those generated by GCC. Inspect the abstract syntax tree (use compilation option \texttt{-fdump-tree-optimized}) and source files.
\end{quote}
\end{framed}

The functions in the \texttt{CHECKME\_CALLED\_FUNCTIONS} list should be treated as functions potentially called within task contexts.  Inspect program sources and exclude those which are not called within tasks.  By looking at Fibonacci program sources, we can exclude \texttt{main} and \texttt{get\_usecs} from the called function list in \texttt{CHECKME\_CALLED\_FUNCTIONS}.

\begin{framed}
\begin{quote}
Tip: If in doubt or when sources are not available, use the entire \texttt{CHECKME\_CALLED\_FUNCTIONS} list.

Expert Tip: Identifying functions called by tasks is necessary because the instruction count of these functions are added to the calling task's instruction count.
\end{quote}
\end{framed}

Start the instruction profiler with appropriate arguments to profile \texttt{fib-prof}.  Also collect task statistics at the same time.

\begin{lstlisting}[style=MyInputStyle]
$ mir-inst-prof \
    -of ol_fib_0,ol_fib_1,ol_fib_2 \
    -cf fib,fib_seq \
    -- ./fib-prof 10 4
\end{lstlisting}

\begin{framed}
\begin{quote}
    Tip: If you plan to use the entire \texttt{CHECKME\_CALLED\_FUNCTIONS} and \texttt{CHECKME\_OUTLINE\_FUNCTIONS} lists, then you can use them as arguments to \texttt{mir-inst-prof} in the following manner:

\begin{lstlisting}[style=MyInputStyle]
$ `$MIR_ROOT/scripts/profiling/task/of_finder.py -e prof-build/*.o`
$ mir-inst-prof \
    -of $CHECKME_OUTLINE_FUNCTIONS
    -cf $CHECKME_CALLED_FUNCTIONS
    -- ./fib-prof 10 4
\end{lstlisting}

The \texttt{-e} option of \texttt{of\_finder.py} outputs outline and called function lists in the BASH export format. The backticks evaluate the output as commands.
\end{quote}
\end{framed}

Inspect instruction profiler output.

\begin{lstlisting}[style=MyInputStyle]
$ head mir-ofp-instructions
$ head mir-ofp-events
\end{lstlisting}

Inspect task statistics.

\begin{lstlisting}[style=MyInputStyle]
$ head mir-task-stats
\end{lstlisting}

Summarize task statistics.

\begin{lstlisting}[style=MyInputStyle]
$ Rscript ${MIR_ROOT}/scripts/profiling/task/process-task-stats.R -d mir-task-stats
$ cat mir-task-stats.info
$ head mir-task-stats.processed
$ head mir-task-stats.lineage
\end{lstlisting}

Combine the instruction-level information produced by the instruction profiler with the task statistics produced by the runtime system into a single CSV file. Note that these files come from the same run.

\begin{lstlisting}[style=MyInputStyle]
$ Rscript ${MIR_ROOT}/scripts/profiling/task/merge-task-performance.R -l mir-task-stats.processed -r mir-ofp-instructions -k "task" -o mir-task-perf
\end{lstlisting}

Plot task graph using combined performance information and view on the yEd graph viewer.

\begin{lstlisting}[style=MyInputStyle]
$ Rscript ${MIR_ROOT}/scripts/profiling/task/plot-task-graph.R -d mir-task-perf -p color
$ yed task-graph.graphml
\end{lstlisting}

\begin{framed}
\begin{quote}
Tip: Import task graph property mapping settings in MIR\_ROOT/scripts/profiling/task/yed-mir-task-graph-settings.cnfx into yEd.
\end{quote}
\end{framed}

TODO: Demonstrate automatic analysis of task performance problems using \texttt{analyze} option of the task graph plotter.

\end{document}
