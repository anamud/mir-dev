To aid MIR task graph analysis, we have built a tool using Intel pin which instruments MIR applications at a task level.
The tool, called "mir_routine_trace.so" essentially instruments functions.
In the MIR world, tasks instances are function calls.
Therefore the tool applies.

The tool instruments functions and produces the following details in csv format:
function call start time instant, number of instructions executed, memory footprint size, computation to communication ratio, computation to load ratio, number of load instructions, number of store instructions

The tool optionally provides information regarding memory sharing between functions.

Details produced by the tool can be bound to the task graph produced by MIR using the R script "mir-callgraph-taskgraph-id-bind.R". 
The script produces a table in csv format which correlates task ids with call graph ids.

Currently, the tool output is intended to be analysed manually. 
The analyser can get information about a task node in the task graph by looking up the task id in the table produced by the bind script.
In the future, we intend to produce a GUI/API based framework which supports retrieving information about task graph elements in a intuitive manner.

=== Requirements ===
Intel Pin version 2.12 or later
MIR revision from 2013 August or later
[Optional] R version 3.0.1
[Optional] Graphviz
[Optional] ZGRViewer

=== Build ===
[ananya@gothmog]$ make PIN_ROOT=/local/ananya/survival_tools/pin-2.12-58423-gcc.4.4.7-linux

=== Pre-run setup ===
[ananya@gothmog]$ export PIN_ROOT=/local/ananya/survival_tools/pin-2.12-58423-gcc.4.4.7-linux ;
[ananya@gothmog]$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/local/ananya/survival_tools/pin-2.12-58423-gcc.4.4.7-linux/intel64/runtime

=== Tool option name, default value, description ===
"o", "mir_call_graph", "specify mir routine trace file suffix"
"i", "0", "append pid to output"
"s", "", "specify routines (csv) to trace"
"c", "", "specify routines (csv) that are called from traced routines"
"m", "0", "calculate memory sharing (a time consuming process!)"

=== Execute ===
Configure MIR to run sequentially (-w=1) and produce task graph (-g):
[ananya@gothmog]$ MIR_CONF="-w=1 -g" $PIN_ROOT/intel64/bin/pinbin -t obj-intel64/mir_routine_trace.so <tool_options> -- <application invocation>  

=== Graph analysis ===
To produce a csv file which binds the call graph with the task graph:
[ananya@gothmog]$ Rscript mir-callgraph-taskgraph-id-bind.R <mir_task_graph> <mir_call_graph>

To plot the sharing graph in dot format:
[ananya@gothmog]$ Rscript mir-share-graph-plot.R <memory_sharing_detail> <sharing lower limit> <sharing upper limit> 

To plot the task graph in dot format:
[ananya@gothmog]$ Rscript mir-task-graph-plot.R <mir_task_graph> 

=== Usage example with MIR fibonacci ===
[ananya@gothmog]$ MIR_CONF="-w=1 -g" $PIN_ROOT/intel64/bin/pinbin -t obj-intel64/mir_routine_trace.so -o fib_call_graph -s fib -c fib_seq -- $MIR_ROOT/test/fib/fib-prof 42 12
5.855132s
Finalizing ...
Writing memory map (/proc/<pid>/maps) to file: fib_call_graph.mmap ...
Updating statistics in parallel ...
Using 48 threads
Updating memory footprint ...
Writing detail to file: fib_call_graph.detail.csv ...
[ananya@gothmog]$ mv mir-task-graph fib_call_graph
[ananya@gothmog]$ Rscript mir-callgraph-taskgraph-id-bind.R fib_task_graph fib_call_graph.detail.csv 
[1] "Writing file fib_call_graph.detail.csv.bind.csv"
[ananya@gothmog]$ Rscript mir-task-graph-plot.R fib_task_graph 
[1] "Writing file fib_task_graph.dot"
[ananya@gothmog]$ dot -T png fib_task_graph.dot > fib_task_graph.png

=== Additional information ===
Please contact ananya@kth.se


